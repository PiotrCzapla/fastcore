# fastcore Module Documentation

## fastcore.ansi

> Filters for processing ANSI colors.

- `def strip_ansi(source)`
    Remove ANSI escape codes from text.

- `def ansi2html(text)`
    Convert ANSI colors to HTML colors.

- `def ansi2latex(text)`
    Convert ANSI colors to LaTeX colors.

## fastcore.basics

> Basic functionality used in the fastai library

- `def ifnone(a, b)`
    `b` if `a` is None else `a`

- `def maybe_attr(o, attr)`
    `getattr(o,attr,o)`

- `def basic_repr(flds)`
    Minimal `__repr__`

- `class BasicRepr`
    Base class for objects needing a basic `__repr__`


- `def is_array(x)`
    `True` if `x` supports `__array__` or `iloc`

- `def listify(o, *rest)`
    Convert `o` to a `list`

- `def tuplify(o, use_list, match)`
    Make `o` a tuple

- `def true(x)`
    Test whether `x` is truthy; collections with >0 elements are considered `True`

- `class NullType`
    An object that is `False` and can be called, chained, and indexed

    - `def __getattr__(self, *args)`
    - `def __call__(self, *args, **kwargs)`
    - `def __getitem__(self, *args)`
    - `def __bool__(self)`

- `def tonull(x)`
    Convert `None` to `null`

- `def get_class(nm, *fld_names, **flds)`
    Dynamically create a class, optionally inheriting from `sup`, containing `fld_names`

- `def mk_class(nm, *fld_names, **flds)`
    Create a class using `get_class` and add to the caller's module

- `def wrap_class(nm, *fld_names, **flds)`
    Decorator: makes function a method of a new class `nm` passing parameters to `mk_class`

- `class ignore_exceptions`
    Context manager to ignore exceptions

    - `def __enter__(self)`
    - `def __exit__(self, *args)`

- `def exec_local(code, var_name)`
    Call `exec` on `code` and return the var `var_name`

- `def risinstance(types, obj)`
    Curried `isinstance` but with args reversed

- `class Inf`
    Infinite lists


- `def in_(x, a)`
    `True` if `x in a`

- `def ret_true(*args, **kwargs)`
    Predicate: always `True`

- `def ret_false(*args, **kwargs)`
    Predicate: always `False`

- `def stop(e)`
    Raises exception `e` (by default `StopIteration`)

- `def gen(func, seq, cond)`
    Like `(func(o) for o in seq if cond(func(o)))` but handles `StopIteration`

- `def chunked(it, chunk_sz, drop_last, n_chunks)`
    Return batches from iterator `it` of size `chunk_sz` (or return `n_chunks` total)

- `def otherwise(x, tst, y)`
    `y if tst(x) else x`

- `def custom_dir(c, add)`
    Implement custom `__dir__`, adding `add` to `cls`

- `class AttrDict`
    `dict` subclass that also provides access to keys as attrs

    - `def __getattr__(self, k)`
    - `def __setattr__(self, k, v)`
    - `def __dir__(self)`
    - `def copy(self)`

- `class AttrDictDefault`
    `AttrDict` subclass that returns `None` for missing attrs

    - `def __init__(self, *args, **kwargs)`
    - `def __getattr__(self, k)`

- `class NS`
    `SimpleNamespace` subclass that also adds `iter` and `dict` support

    - `def __iter__(self)`
    - `def __getitem__(self, x)`
    - `def __setitem__(self, x, y)`

- `def get_annotations_ex(obj)`
    Backport of py3.10 `get_annotations` that returns globals/locals

- `def eval_type(t, glb, loc)`
    `eval` a type or collection of types, if needed, for annotations in py3.10+

- `def type_hints(f)`
    Like `typing.get_type_hints` but returns `{}` if not allowed type

- `def annotations(o)`
    Annotations for `o`, or `type(o)`

- `def anno_ret(func)`
    Get the return annotation of `func`

- `def signature_ex(obj, eval_str)`
    Backport of `inspect.signature(..., eval_str=True` to <py310

- `def argnames(f, frame)`
    Names of arguments to function or frame `f`

- `def with_cast(f)`
    Decorator which uses any parameter annotations as preprocessing functions

- `def store_attr(names, self, but, cast, store_args, **attrs)`
    Store params named in comma-separated `names` from calling context into attrs in `self`

- `def attrdict(o, *ks)`
    Dict from each `k` in `ks` to `getattr(o,k)`

- `def properties(cls, *ps)`
    Change attrs in `cls` with names in `ps` to properties

- `def camel2words(s, space)`
    Convert CamelCase to 'spaced words'

- `def camel2snake(name)`
    Convert CamelCase to snake_case

- `def snake2camel(s)`
    Convert snake_case to CamelCase

- `def class2attr(self, cls_name)`
    Return the snake-cased name of the class; strip ending `cls_name` if it exists.

- `def getcallable(o, attr)`
    Calls `getattr` with a default of `noop`

- `def getattrs(o, *attrs)`
    List of all `attrs` in `o`

- `def hasattrs(o, attrs)`
    Test whether `o` contains all `attrs`

- `def try_attrs(obj, *attrs)`
    Return first attr that exists in `obj`

- `class GetAttrBase`
    Basic delegation of `__getattr__` and `__dir__`

    - `def __getattr__(self, k)`
    - `def __dir__(self)`

- `class GetAttr`
    Inherit from this to have all attr accesses in `self._xtra` passed down to `self.default`

    - `def __getattr__(self, k)`
    - `def __dir__(self)`
    - `def __setstate__(self, data)`

- `def delegate_attr(self, k, to)`
    Use in `__getattr__` to delegate to attr `to` without inheriting from `GetAttr`

- `class ShowPrint`
    Base class that prints for `show`

    - `def show(self, *args, **kwargs)`

- `class Int`
    An extensible `int`


- `class Str`
    An extensible `str`


- `class Float`
    An extensible `float`


- `def partition(coll, f)`
    Partition a collection by a predicate

- `def partition_dict(d, f)`
    Partition a dict by a predicate that takes key/value params

- `def flatten(o)`
    Concatenate all collections and items as a generator

- `def concat(colls)`
    Concatenate all collections and items as a list

- `def strcat(its, sep)`
    Concatenate stringified items `its`

- `def detuplify(x)`
    If `x` is a tuple with one thing, extract it

- `def replicate(item, match)`
    Create tuple of `item` copied `len(match)` times

- `def setify(o)`
    Turn any list like-object into a set.

- `def merge(*ds)`
    Merge all dictionaries in `ds`

- `def range_of(x)`
    All indices of collection `x` (i.e. `list(range(len(x)))`)

- `def groupby(x, key, val)`
    Like `itertools.groupby` but doesn't need to be sorted, and isn't lazy, plus some extensions

- `def last_index(x, o)`
    Finds the last index of occurence of `x` in `o` (returns -1 if no occurence)

- `def filter_dict(d, func)`
    Filter a `dict` using `func`, applied to keys and values

- `def filter_keys(d, func)`
    Filter a `dict` using `func`, applied to keys

- `def filter_values(d, func)`
    Filter a `dict` using `func`, applied to values

- `def cycle(o)`
    Like `itertools.cycle` except creates list of `None`s if `o` is empty

- `def zip_cycle(x, *args)`
    Like `itertools.zip_longest` but `cycle`s through elements of all but first argument

- `def sorted_ex(iterable, key, reverse, cmp, **kwargs)`
    Like `sorted`, but if key is str use `attrgetter`; if int use `itemgetter`; use `cmp` comparator function or `key` with `kwargs`

- `def not_(f)`
    Create new function that negates result of `f`

- `def argwhere(iterable, f, negate, **kwargs)`
    Like `filter_ex`, but return indices for matching items

- `def filter_ex(iterable, f, negate, gen, **kwargs)`
    Like `filter`, but passing `kwargs` to `f`, defaulting `f` to `noop`, and adding `negate` and `gen`

- `def renumerate(iterable, start)`
    Same as `enumerate`, but returns index as 2nd element instead of 1st

- `def first(x, f, negate, **kwargs)`
    First element of `x`, optionally filtered by `f`, or None if missing

- `def last(x, f, negate, **kwargs)`
    Last element of `x`, optionally filtered by `f`, or None if missing

- `def only(o)`
    Return the only item of `o`, raise if `o` doesn't have exactly one item

- `def nested_attr(o, attr, default)`
    Same as `getattr`, but if `attr` includes a `.`, then looks inside nested objects

- `def nested_setdefault(o, attr, default)`
    Same as `setdefault`, but if `attr` includes a `.`, then looks inside nested objects

- `def nested_callable(o, attr)`
    Same as `nested_attr` but if not found will return `noop`

- `def nested_idx(coll, *idxs)`
    Index into nested collections, dicts, etc, with `idxs`

- `def set_nested_idx(coll, value, *idxs)`
    Set value indexed like `nested_idx

- `def val2idx(x)`
    Dict from value to index

- `def uniqueify(x, sort, bidir, start)`
    Unique elements in `x`, optional `sort`, optional return reverse correspondence, optional prepend with elements.

- `def loop_first_last(values)`
    Iterate and generate a tuple with a flag for first and last value.

- `def loop_first(values)`
    Iterate and generate a tuple with a flag for first value.

- `def loop_last(values)`
    Iterate and generate a tuple with a flag for last value.

- `def first_match(lst, f, default)`
    First element of `lst` matching predicate `f`, or `default` if none

- `def last_match(lst, f, default)`
    Last element of `lst` matching predicate `f`, or `default` if none

- `class fastuple`
    A `tuple` with elementwise ops and more friendly __init__ behavior

    - `def __new__(cls, x, *rest)`
    - `def mul(self, *args)`
        `*` is already defined in `tuple` for replicating, so use `mul` instead

    - `def add(self, *args)`
        `+` is already defined in `tuple` for concat, so use `add` instead


- `class bind`
    Same as `partial`, except you can use `arg0` `arg1` etc param placeholders

    - `def __init__(self, func, *pargs, **pkwargs)`
    - `def __call__(self, *args, **kwargs)`

- `def mapt(func, *iterables)`
    Tuplified `map`

- `def map_ex(iterable, f, *args, **kwargs)`
    Like `map`, but use `bind`, and supports `str` and indexing

- `def compose(*funcs)`
    Create a function that composes all functions in `funcs`, passing along remaining `*args` and `**kwargs` to all

- `def maps(*args)`
    Like `map`, except funcs are composed first

- `def partialler(f, *args, **kwargs)`
    Like `functools.partial` but also copies over docstring

- `def instantiate(t)`
    Instantiate `t` if it's a type, otherwise do nothing

- `def using_attr(f, attr)`
    Construct a function which applies `f` to the argument's attribute `attr`

- `def negate(f)`
    Returns the negation of `f`

- `def spread(f)`
    Wrap `f` to accept a single iterable and spread it as positional args

- `def dspread(f)`
    Wrap `f` to accept a single dict and spread it as keyword args

- `def copy_func(f)`
    Copy a non-builtin function (NB `copy.copy` does not work for this)

- `def patch_to(cls, as_prop, cls_method, set_prop, nm, glb)`
    Decorator: add `f` to `cls`

- `def patch(f)`
    Decorator: add `f` to the first parameter's class (based on f's type annotations)

- `def compile_re(pat)`
    Compile `pat` if it's not None

- `class ImportEnum`
    An `Enum` that can have its values imported

    - `@classmethod def imports(cls)`
    - `@property def name(self)`
        The name of the Enum member.

    This is a reconstruction by astroid: enums are too dynamic to understand, but we at least
    know 'name' should be a string, so this is astroid's best guess.


- `class StrEnum`
    An `ImportEnum` that behaves like a `str`

    - `def __str__(self)`
    - `@property def name(self)`
        The name of the Enum member.

    This is a reconstruction by astroid: enums are too dynamic to understand, but we at least
    know 'name' should be a string, so this is astroid's best guess.


- `def str_enum(name, *vals)`
    Simplified creation of `StrEnum` types

- `class ValEnum`
    An `ImportEnum` that stringifies using values

    - `def __str__(self)`
    - `@property def name(self)`
        The name of the Enum member.

    This is a reconstruction by astroid: enums are too dynamic to understand, but we at least
    know 'name' should be a string, so this is astroid's best guess.


- `class Stateful`
    A base class/mixin for objects that should not serialize all their state

    - `def __init__(self, *args, **kwargs)`
    - `def __getstate__(self)`
    - `def __setstate__(self, state)`

- `class NotStr`
    Behaves like a `str`, but isn't an instance of one

    - `def __init__(self, s)`
    - `def __repr__(self)`
    - `def __str__(self)`
    - `def __add__(self, b)`
    - `def __mul__(self, b)`
    - `def __len__(self)`
    - `def __eq__(self, b)`
    - `def __lt__(self, b)`
    - `def __hash__(self)`
    - `def __bool__(self)`
    - `def __contains__(self, b)`
    - `def __iter__(self)`
    - `def __getitem__(self, i)`

- `class PrettyString`
    Little hack to get strings to show properly in Jupyter.

    - `def __repr__(self)`

- `def even_mults(start, stop, n)`
    Build log-stepped array from `start` to `stop` in `n` steps.

- `def num_cpus()`
    Get number of cpus

- `def add_props(f, g, n)`
    Create properties passing each of `range(n)` to f

- `def str2bool(s)`
    Case-insensitive convert string `s` too a bool (`y`,`yes`,`t`,`true`,`on`,`1`->`True`)

- `def str2int(s)`
    Convert `s` to an `int`

- `def str2float(s)`
    Convert `s` to a float

- `def str2list(s)`
    Convert `s` to a list

- `def str2date(s)`
    `date.fromisoformat` with empty string handling

- `def typed(_func)`
    Decorator to check param and return types at runtime, with optional casting

- `def exec_new(code)`
    Execute `code` in a new environment and return it

- `def exec_import(mod, sym)`
    Import `sym` from `mod` in a new environment

## fastcore.docments

> Document parameters using comments.

- `def docstring(sym)`
    Get docstring for `sym` for functions ad classes

- `def parse_docstring(sym)`
    Parse a numpy-style docstring in `sym`

- `def isdataclass(s)`
    Check if `s` is a dataclass but not a dataclass' instance

- `def get_dataclass_source(s)`
    Get source code for dataclass `s`

- `def get_source(s)`
    Get source code for string, function object or dataclass `s`

- `def get_name(obj)`
    Get the name of `obj`

- `def qual_name(obj)`
    Get the qualified name of `obj`

- `def docments(s, full, eval_str, returns, args_kwargs)`
    Get docments for `s`

- `def sig_source(obj)`
    Full source of signature line(s) for a function or class.

- `def extract_docstrings(code)`
    Create a dict from function/class/method names to tuples of docstrings and param lists

- `class DocmentTbl`
    - `def __init__(self, obj, verbose, returns)`
        Compute the docment table string

    - `@property def has_docment(self)`
    - `@property def has_return(self)`
    - `@property def hdr_str(self)`
    - `@property def params_str(self)`
    - `@property def return_str(self)`
    - `def __eq__(self, other)`

- `class DocmentList`

- `class DocmentText`
    - `def __init__(self, obj, maxline, docstring)`
    - `@property def params(self)`
    - `def __str__(self)`

- `def sig2str(func, maxline)`
    Generate function signature with docments as comments

- `class ShowDocRenderer`
    - `def __init__(self, sym, name, title_level, maxline)`
        Show documentation for `sym`


- `class MarkdownRenderer`
    Markdown renderer for `show_doc`


## fastcore.docscrape

> Parse numpy-style docstrings

- `def strip_blank_lines(l)`
    Remove leading and trailing blank lines from a list of lines

- `class Reader`
    A line-based string reader.

    - `def __init__(self, data)`
    - `def __getitem__(self, n)`
    - `def reset(self)`
    - `def read(self)`
    - `def seek_next_non_empty_line(self)`
    - `def eof(self)`
    - `def read_to_condition(self, condition_func)`
    - `def read_to_next_empty_line(self)`
    - `def read_to_next_unindented_line(self)`
    - `def peek(self, n)`
    - `def is_empty(self)`

- `class ParseError`
    - `def __str__(self)`

- `class NumpyDocString`
    Parses a numpydoc string to an abstract representation

    - `def __init__(self, docstring, config, supported_sections, supports_params)`
    - `def __iter__(self)`
    - `def __len__(self)`
    - `def __getitem__(self, key)`
    - `def __setitem__(self, key, val)`

- `def dedent_lines(lines, split)`
    Deindent a list of lines maximally

## fastcore.foundation

> The `L` class and helpers for it

- `@contextmanager def working_directory(path)`
    Change working directory to `path` and return to previous on exit.

- `def add_docs(cls, cls_doc, **docs)`
    Copy values from `docs` to `cls` docstrings, and confirm all public methods are documented

- `def docs(cls)`
    Decorator version of `add_docs`, using `_docs` dict

- `def coll_repr(c, max_n)`
    String repr of up to `max_n` items of (possibly lazy) collection `c`

- `def is_bool(x)`
    Check whether `x` is a bool or None

- `def mask2idxs(mask)`
    Convert bool mask or index list to index `L`

- `def is_indexer(idx)`
    Test whether `idx` will index a single item in a list

- `def product(xs)`
    The product of elements of `xs`, with `None`s removed

- `def flatmap(f, xs)`
    Apply f to each element and flatten the results into a single list.

- `class CollBase`
    Base class for composing a list of `items`

    - `def __init__(self, items)`
    - `def __len__(self)`
    - `def __getitem__(self, k)`
    - `def __setitem__(self, k, v)`
    - `def __delitem__(self, i)`
    - `def __repr__(self)`
    - `def __iter__(self)`

- `class L`
    Behaves like a list of `items` but can also index with list of indices or masks

    - `def __init__(self, items, *rest)`
    - `def __getitem__(self, idx)`
        Retrieve `idx` (can be list of indices, or mask, or int) items

    - `def __setitem__(self, idx, o)`
        Set `idx` (can be list of indices, or mask, or int) items to `o` (which is broadcast if not iterable)

    - `def __eq__(self, b)`
    - `def __iter__(self)`
    - `def __contains__(self, b)`
    - `def __reversed__(self)`
    - `def __invert__(self)`
    - `def __repr__(self)`
    - `def __mul__(a, b)`
    - `def __add__(a, b)`
    - `def __radd__(a, b)`
    - `def __addi__(a, b)`

- `@patch def unique(self, sort, bidir, start)`
    Unique items, in stable order

- `@patch(cls_method=True) def range(cls, a, b, step)`
    Class Method: Same as `range`, but returns `L`. Can pass collection for `a`, to use `len(a)`

- `@patch def enumerate(self)`
    Same as `enumerate`

- `@patch(cls_method=True) def split(cls, s, sep, maxsplit)`
    Class Method: Same as `str.split`, but returns an `L`

- `@patch(cls_method=True) def splitlines(cls, s, keepends)`
    Class Method: Same as `str.splitlines`, but returns an `L`

- `@patch @curryable def map(self, f, *args, **kwargs)`
    Create new `L` with `f` applied to all `items`, passing `args` and `kwargs` to `f`

- `def splitter(sep, maxsplit)`
    Create a partial function that splits strings into `L`

- `def linesplitter(keepends)`
    Create a partial function that splits strings by lines into `L`

- `@patch @curryable def starmap(self, f, *args, **kwargs)`
    Like `map`, but use `itertools.starmap`

- `@patch @curryable def rstarmap(self, f, *args, **kwargs)`
    Like `starmap`, but reverse the order of args

- `@patch def map_dict(self, f, *args, **kwargs)`
    Like `map`, but creates a dict from `items` to function results

- `@patch def zip(self, cycled)`
    Create new `L` with `zip(*items)`

- `@patch def map_zip(self, f, *args, **kwargs)`
    Combine `zip` and `starmap`

- `@patch def zipwith(self, *rest)`
    Create new `L` with `self` zip with each of `*rest`

- `@patch def map_zipwith(self, f, *rest, **kwargs)`
    Combine `zipwith` and `starmap`

- `@patch @curryable def filter(self, f, negate, **kwargs)`
    Create new `L` filtered by predicate `f`, passing `args` and `kwargs` to `f`

- `@patch @curryable def starfilter(self, f, negate, **kwargs)`
    Like `filter`, but unpacks elements as args to `f`

- `@patch @curryable def rstarfilter(self, f, negate, **kwargs)`
    Like `starfilter`, but reverse the order of args

- `@patch @curryable def starargwhere(self, f, negate)`
    Like `argwhere`, but unpacks elements as args to `f`

- `@patch @curryable def rstarargwhere(self, f, negate)`
    Like `starargwhere`, but reverse the order of args

- `@patch @curryable def argfirst(self, f, negate)`
    Return index of first matching item

- `@patch @curryable def starargfirst(self, f, negate)`
    Like `argfirst`, but unpacks elements as args to `f`

- `@patch @curryable def rstarargfirst(self, f, negate)`
    Like `starargfirst`, but reverse the order of args

- `@patch def itemgot(self, *idxs)`
    Create new `L` with item `idx` of all `items`

- `@patch def attrgot(self, k, default)`
    Create new `L` with attr `k` (or value `k` for dicts) of all `items`.

- `@patch @curryable def sorted(self, key, reverse, cmp, **kwargs)`
    New `L` sorted by `key`, using `sort_ex`. If key is str use `attrgetter`; if int use `itemgetter`

- `@patch @curryable def starsorted(self, key, reverse)`
    Like `sorted`, but unpacks elements as args to `key`

- `@patch @curryable def rstarsorted(self, key, reverse)`
    Like `starsorted`, but reverse the order of args

- `@patch def shuffle(self)`
    Same as `random.shuffle`, but not inplace

- `@patch @curryable def starreduce(self, f, initial)`
    Like `reduce`, but unpacks elements as args to `f`

- `@patch @curryable def rstarreduce(self, f, initial)`
    Like `starreduce`, but reverse the order of unpacked args

- `@patch def sum(self)`
    Sum of the items

- `@patch def map_first(self, f, g, *args, **kwargs)`
    First element of `map_filter`

- `@patch @curryable def takewhile(self, f)`
    Same as `itertools.takewhile`

- `@patch @curryable def dropwhile(self, f)`
    Same as `itertools.dropwhile`

- `@patch @curryable def startakewhile(self, f)`
    Like `takewhile`, but unpacks elements as args to `f`

- `@patch @curryable def rstartakewhile(self, f)`
    Like `startakewhile`, but reverse the order of args

- `@patch @curryable def stardropwhile(self, f)`
    Like `dropwhile`, but unpacks elements as args to `f`

- `@patch @curryable def rstardropwhile(self, f)`
    Like `stardropwhile`, but reverse the order of args

- `@patch @curryable def accumulate(self, f, initial)`
    Same as `itertools.accumulate`

- `@patch def pairwise(self)`
    Same as `itertools.pairwise`

- `@patch def compress(self, selectors)`
    Same as `itertools.compress`

- `@patch def permutations(self, r)`
    Same as `itertools.permutations`

- `@patch def combinations(self, r)`
    Same as `itertools.combinations`

- `@patch @curryable def starpartition(self, f, **kwargs)`
    Like `partition`, but unpacks elements as args to `f`

- `@patch @curryable def rstarpartition(self, f, **kwargs)`
    Like `starpartition`, but reverse the order of args

- `def save_config_file(file, d, **kwargs)`
    Write settings dict to a new config file, or overwrite the existing one.

- `class Config`
    Reading and writing `ConfigParser` ini files

    - `def __init__(self, cfg_path, cfg_name, create, save, extra_files, types, **cfg_kwargs)`
    - `def __repr__(self)`
    - `def __setitem__(self, k, v)`
    - `def __contains__(self, k)`
    - `def save(self)`
    - `def __getattr__(self, k)`
    - `def __getitem__(self, k)`
    - `def get(self, k, default)`
    - `def path(self, k, default)`
    - `@classmethod def find(cls, cfg_name, cfg_path, **kwargs)`
        Search `cfg_path` and its parents to find `cfg_name`


## fastcore.imghdr

> Recognize image file formats based on their first few bytes.

- `def test_jpeg(h, f)`
    JPEG data with JFIF or Exif markers; and raw JPEG including COM segments

- `def test_gif(h, f)`
    GIF ('87 and '89 variants)

- `def test_tiff(h, f)`
    TIFF (can be in Motorola or Intel byte order)

- `def test_rgb(h, f)`
    SGI image library

- `def test_pbm(h, f)`
    PBM (portable bitmap)

- `def test_pgm(h, f)`
    PGM (portable graymap)

- `def test_ppm(h, f)`
    PPM (portable pixmap)

- `def test_rast(h, f)`
    Sun raster file

- `def test_xbm(h, f)`
    X bitmap (X10 or X11)

## fastcore.imports

- `def is_iter(o)`
    Test whether `o` can be used in a `for` loop

- `def is_coll(o)`
    Test whether `o` is a collection (i.e. has a usable `len`)

- `def all_equal(a, b)`
    Compares whether `a` and `b` are the same length and have the same contents

- `def noop(x, *args, **kwargs)`
    Do nothing

- `def noops(self, x, *args, **kwargs)`
    Do nothing (method)

- `def isinstance_str(x, cls_name)`
    Like `isinstance`, except takes a type name instead of a type

- `def equals(a, b)`
    Compares `a` and `b` for equality; supports sublists, tensors and arrays too

- `def ipython_shell()`
    Same as `get_ipython` but returns `False` if not in IPython

- `def in_ipython()`
    Check if code is running in some kind of IPython environment

- `def in_colab()`
    Check if the code is running in Google Colaboratory

- `def in_jupyter()`
    Check if the code is running in a jupyter notebook

- `def in_notebook()`
    Check if the code is running in a jupyter notebook

- `def remove_prefix(text, prefix)`
    Temporary until py39 is a prereq

- `def remove_suffix(text, suffix)`
    Temporary until py39 is a prereq

## fastcore.meta

> Metaclasses

- `def test_sig(f, b)`
    Test the signature of an object

- `class FixSigMeta`
    A metaclass that fixes the signature on classes that override `__new__`

    - `def __new__(cls, name, bases, dict)`

- `class PrePostInitMeta`
    A metaclass that calls optional `__pre_init__` and `__post_init__` methods

    - `def __call__(cls, *args, **kwargs)`

- `class AutoInit`
    Same as `object`, but no need for subclasses to call `super().__init__`

    - `def __pre_init__(self, *args, **kwargs)`

- `class NewChkMeta`
    Metaclass to avoid recreating object passed to constructor

    - `def __call__(cls, x, *args, **kwargs)`

- `class BypassNewMeta`
    Metaclass: casts `x` to this class if it's of type `cls._bypass_type`

    - `def __call__(cls, x, *args, **kwargs)`

- `def empty2none(p)`
    Replace `Parameter.empty` with `None`

- `def anno_dict(f)`
    `__annotation__ dictionary with `empty` cast to `None`, returning empty if doesn't exist

- `def use_kwargs_dict(keep, **kwargs)`
    Decorator: replace `**kwargs` in signature with `names` params

- `def use_kwargs(names, keep)`
    Decorator: replace `**kwargs` in signature with `names` params

- `def delegates(to, keep, but, sort_args)`
    Decorator: replace `**kwargs` in signature with params from `to`

- `def method(f)`
    Mark `f` as a method

- `def funcs_kwargs(as_method)`
    Replace methods in `cls._methods` with those from `kwargs`

## fastcore.net

> Network, HTTP, and URL functions

- `def urlquote(url)`
    Update url's path with `urllib.parse.quote`

- `def urlwrap(url, data, headers)`
    Wrap `url` in a urllib `Request` with `urlquote`

- `class HTTP4xxClientError`
    Base class for client exceptions (code 4xx) from `url*` functions


- `class HTTP5xxServerError`
    Base class for server exceptions (code 5xx) from `url*` functions


- `def urlopen(url, data, headers, timeout, **kwargs)`
    Like `urllib.request.urlopen`, but first `urlwrap` the `url`, and encode `data`

- `def urlread(url, data, headers, decode, return_json, return_headers, timeout, **kwargs)`
    Retrieve `url`, using `data` dict or `kwargs` to `POST` if present

- `def urljson(url, data, headers, timeout)`
    Retrieve `url` and decode json

- `def urlclean(url)`
    Remove fragment, params, and querystring from `url` if present

- `def urlsave(url, dest, reporthook, headers, timeout)`
    Retrieve `url` and save based on its name

- `def urlvalid(x)`
    Test if `x` is a valid URL

- `def urlrequest(url, verb, headers, route, query, data, json_data)`
    `Request` for `url` with optional route params replaced by `route`, plus `query` string, and post `data`

- `@patch def summary(self, skip)`
    Summary containing full_url, headers, method, and data, removing `skip` from headers

- `def urlsend(url, verb, headers, decode, route, query, data, json_data, return_json, return_headers, debug, timeout)`
    Send request with `urlrequest`, converting result to json if `return_json`

- `def do_request(url, post, headers, **data)`
    Call GET or json-encoded POST on `url`, depending on `post`

- `def start_server(port, host, dgram, reuse_addr, n_queue)`
    Create a `socket` server on `port`, with optional `host`, of type `dgram`

- `def start_client(port, host, dgram)`
    Create a `socket` client on `port`, with optional `host`, of type `dgram`

- `def tobytes(s)`
    Convert `s` into HTTP-ready bytes format

- `def http_response(body, status, hdrs, **kwargs)`
    Create an HTTP-ready response, adding `kwargs` to `hdrs`

- `@threaded def recv_once(host, port)`
    Spawn a thread to receive a single HTTP request and store in `d['r']`

## fastcore.parallel

> Threading and multiprocessing functions

- `def threaded(process)`
    Run `f` in a `Thread` (or `Process` if `process=True`), and returns it

- `def startthread(f)`
    Like `threaded`, but start thread immediately

- `def startproc(f)`
    Like `threaded(True)`, but start Process immediately

- `class ThreadPoolExecutor`
    Same as Python's ThreadPoolExecutor, except can pass `max_workers==0` for serial execution

    - `def __init__(self, max_workers, on_exc, pause, **kwargs)`
    - `def map(self, f, items, *args, **kwargs)`

- `@delegates() class ProcessPoolExecutor`
    Same as Python's ProcessPoolExecutor, except can pass `max_workers==0` for serial execution

    - `def __init__(self, max_workers, on_exc, pause, **kwargs)`
    - `def map(self, f, items, *args, **kwargs)`

- `def parallel(f, items, *args, **kwargs)`
    Applies `func` in parallel to `items`, using `n_workers`

- `def parallel_async(f, items, *args, **kwargs)`
    Applies `f` to `items` in parallel using asyncio and a semaphore to limit concurrency.

- `def run_procs(f, f_done, args)`
    Call `f` for each item in `args` in parallel, yielding `f_done`

- `def parallel_gen(cls, items, n_workers, **kwargs)`
    Instantiate `cls` in `n_workers` procs & call each on a subset of `items` in parallel.

## fastcore.py2pyi

- `def imp_mod(module_path, package)`
    Import dynamically the module referenced in `fn`

- `def has_deco(node, name)`
    Check if a function node `node` has a decorator named `name`

- `def create_pyi(fn, package)`
    Convert `fname.py` to `fname.pyi` by removing function bodies and expanding `delegates` kwargs

- `@call_parse def py2pyi(fname, package)`
    Convert `fname.py` to `fname.pyi` by removing function bodies and expanding `delegates` kwargs

- `@call_parse def replace_wildcards(path)`
    Expand wildcard imports in the specified Python file.

## fastcore.script

> A fast way to turn your python function into a script.

- `def store_true()`
    Placeholder to pass to `Param` for `store_true` action

- `def store_false()`
    Placeholder to pass to `Param` for `store_false` action

- `def bool_arg(v)`
    Use as `type` for `Param` to get `bool` behavior

- `class Param`
    A parameter in a function used in `anno_parser` or `call_parse`

    - `def __init__(self, help, type, opt, action, nargs, const, choices, required, default, version)`
    - `def set_default(self, d)`
    - `@property def pre(self)`
    - `@property def kwargs(self)`
    - `def __repr__(self)`

- `def anno_parser(func, prog)`
    Look at params (annotated with `Param`) in func and return an `ArgumentParser`

- `def args_from_prog(func, prog)`
    Extract args from `prog`

- `def call_parse(func, nested)`
    Decorator to create a simple CLI from `func` using `anno_parser`

## fastcore.style

> Fast styling for friendly CLIs.

- `class StyleCode`
    An escape sequence for styling terminal text.

    - `def __init__(self, name, code, typ)`
    - `def __str__(self)`

- `class Style`
    A minimal terminal text styler.

    - `def __init__(self, codes)`
    - `def __dir__(self)`
    - `def __getattr__(self, k)`
    - `def __call__(self, obj)`
    - `def __repr__(self)`

- `def demo()`
    Demonstrate all available styles and their codes.

## fastcore.test

> Helper functions to quickly write tests in notebooks

- `def test_fail(f, msg, contains, exc, args, kwargs)`
    Fails with `msg` unless `f()` raises an exception of type `exc` and (optionally) has `contains` in `e.args`

- `def test(a, b, cmp, cname)`
    `assert` that `cmp(a,b)`; display inputs and `cname or cmp.__name__` if it fails

- `def nequals(a, b)`
    Compares `a` and `b` for `not equals`

- `def test_eq(a, b)`
    `test` that `a==b`

- `def test_eq_type(a, b)`
    `test` that `a==b` and are same type

- `def test_ne(a, b)`
    `test` that `a!=b`

- `def is_close(a, b, eps)`
    Is `a` within `eps` of `b`

- `def test_close(a, b, eps)`
    `test` that `a` is within `eps` of `b`

- `def test_is(a, b)`
    `test` that `a is b`

- `def test_shuffled(a, b)`
    `test` that `a` and `b` are shuffled versions of the same sequence of items

- `def test_stdout(f, exp, regex)`
    Test that `f` prints `exp` to stdout, optionally checking as `regex`

- `def test_fig_exists(ax)`
    Test there is a figure displayed in `ax`

- `class ExceptionExpected`
    Context manager that tests if an exception is raised

    - `def __init__(self, ex, regex)`
    - `def __enter__(self)`
    - `def __exit__(self, type, value, traceback)`

## fastcore.tools

> Helpful tools for running cli commands and reading, modifying, and creating files in python. This is used primarily for AI's in tool loops for automating tasks involving the filesystem.

- `def run_cmd(cmd, argstr, disallow_re, allow_re)`
    Run `cmd` passing split `argstr`, optionally checking for allowed argstr

- `def rg(argstr, disallow_re, allow_re)`
    Run the `rg` command with the args in `argstr` (no need to backslash escape)

- `def sed(argstr, disallow_re, allow_re)`
    Run the `sed` command with the args in `argstr` (e.g for reading a section of a file)

- `def view(path, view_range, nums)`
    View directory or file contents with optional line range and numbers

- `def create(path, file_text, overwrite)`
    Creates a new file with the given content at the specified path

- `def insert(path, insert_line, new_str)`
    Insert new_str at specified line number

- `def str_replace(path, old_str, new_str)`
    Replace first occurrence of old_str with new_str in file

- `def strs_replace(path, old_strs, new_strs)`
    Replace for each str pair in old_strs,new_strs

- `def replace_lines(path, start_line, end_line, new_content)`
    Replace lines in file using start and end line-numbers (index starting at 1)

- `def move_lines(path, start_line, end_line, dest_line)`
    Move lines from start_line:end_line to before dest_line

- `def get_callable()`
    Return callable objects defined in caller's module

## fastcore.xdg

> XDG Base Directory Specification helpers.

- `def xdg_cache_home()`
    Path corresponding to `XDG_CACHE_HOME`

- `def xdg_config_dirs()`
    Paths corresponding to `XDG_CONFIG_DIRS`

- `def xdg_config_home()`
    Path corresponding to `XDG_CONFIG_HOME`

- `def xdg_data_dirs()`
    Paths corresponding to XDG_DATA_DIRS`

- `def xdg_data_home()`
    Path corresponding to `XDG_DATA_HOME`

- `def xdg_runtime_dir()`
    Path corresponding to `XDG_RUNTIME_DIR`

- `def xdg_state_home()`
    Path corresponding to `XDG_STATE_HOME`

## fastcore.xml

> Concise generation of XML.

- `class FT`
    A 'Fast Tag' structure, containing `tag`,`children`,and `attrs`

    - `def __init__(self, tag, cs, attrs, void_, **kwargs)`
    - `def on(self, f)`
    - `def changed(self)`
    - `def __setattr__(self, k, v)`
    - `def __getattr__(self, k)`
    - `@property def list(self)`
    - `def get(self, k, default)`
    - `def __repr__(self)`
    - `def __iter__(self)`
    - `def __getitem__(self, idx)`
    - `def __setitem__(self, i, o)`
    - `def __call__(self, *c, **kw)`
    - `def set(self, *c, **kw)`
        Set children and/or attributes (chainable)


- `def ft(tag, *c, **kw)`
    Create an `FT` structure for `to_xml()`

- `def Html(*c, **kwargs)`
    An HTML tag, optionally preceeded by `!DOCTYPE HTML`

- `class Safe`
    - `def __html__(self)`

- `def to_xml(elm, lvl, indent, do_escape)`
    Convert `ft` element tree into an XML string

- `def highlight(s, lang)`
    Markdown to syntax-highlight `s` in language `lang`

## fastcore.xtras

> Utility functions used in the fastai library

- `def walk(path, symlinks, keep_file, keep_folder, skip_folder, func, ret_folders, sort)`
    Generator version of `os.walk`, using functions to filter files and folders

- `def exttypes(types)`
    Get exts for comma-separated or list `typ`; if not found in list, return list with just `types`.
    Supported: py, js, java, c, cpp, rb, r, ex, sh, web, doc, cfg

- `def globtastic(path, recursive, symlinks, file_glob, file_re, folder_re, skip_file_glob, skip_file_re, skip_folder_re, func, ret_folders, sort, types, exts)`
    A more powerful `glob`, including regex matches, symlink handling, and skip parameters

- `@fdelegates(globtastic) def pglob(path, func, **kwargs)`
    Shortcut for `globtastic(..., call=Path)`

- `@contextmanager def maybe_open(f, mode, **kwargs)`
    Context manager: open `f` if it is a path (and close on exit)

- `def mkdir(path, exist_ok, parents, overwrite, **kwargs)`
    Creates and returns a directory defined by `path`, optionally removing previous existing directory if `overwrite` is `True`

- `def image_size(fn)`
    Tuple of (w,h) for png, gif, or jpg; `None` otherwise

- `def detect_mime(data)`
    Get the MIME type for bytes `data`, covering common PDF, audio, video, and image types

- `def bunzip(fn)`
    bunzip `fn`, raising exception if output already exists

- `def loads(s, **kw)`
    Same as `json.loads`, but handles `None`

- `def loads_multi(s)`
    Generator of >=0 decoded json dicts, possibly with non-json ignored text at start and end

- `def dumps(obj, **kw)`
    Same as `json.dumps`, but uses `ujson` if available

- `def untar_dir(fname, dest, rename, overwrite)`
    untar `file` into `dest`, creating a directory if the root contains more than one item

- `def repo_details(url)`
    Tuple of `owner,name` from ssh or https git repo `url`

- `def shell(*args, **kwargs)`
    Shortcut for `subprocess.run(shell=True)`

- `def ssh(host, args, user, sock)`
    Run SSH command with given arguments

- `def rsync_multi(ip, files, user, persist)`
    Transfer multiple files with rename using persistent SSH connection

- `def run(cmd, *rest)`
    Pass `cmd` (splitting with `shlex` if string) to `subprocess.run`; return `stdout`; raise `IOError` if fails

- `def open_file(fn, mode, **kwargs)`
    Open a file, with optional compression if gz or bz2 suffix

- `def save_pickle(fn, o)`
    Save a pickle file, to a file name or opened file

- `def load_pickle(fn)`
    Load a pickle file from a file name or opened file

- `def parse_env(s, fn)`
    Parse a shell-style environment string or file

- `def expand_wildcards(code)`
    Expand all wildcard imports in the given code string.

- `def dict2obj(d, list_func, dict_func, **kwargs)`
    Convert (possibly nested) dicts (or lists of dicts) to `AttrDict`

- `def obj2dict(d)`
    Convert (possibly nested) AttrDicts (or lists of AttrDicts) to `dict`

- `def repr_dict(d)`
    Print nested dicts and lists, such as returned by `dict2obj`

- `def is_listy(x)`
    `isinstance(x, (tuple,list,L,slice,Generator))`

- `def mapped(f, it)`
    map `f` over `it`, unless it's not listy, in which case return `f(it)`

- `@patch def readlines(self, hint, encoding)`
    Read the content of `self`

- `@patch def read_json(self, encoding, errors)`
    Same as `read_text` followed by `loads`

- `@patch def mk_write(self, data, encoding, errors, mode, uid, gid)`
    Make all parent dirs of `self`, and write `data`

- `@patch def write_json(self, data, encoding, errors, mode, uid, gid, **kw)`
    Same as `dumps`followed by `mk_write`

- `@patch def relpath(self, start)`
    Same as `os.path.relpath`, but returns a `Path`, and resolves symlinks

- `@patch def ls(self, n_max, file_type, file_exts)`
    Contents of path as a list

- `@patch def normpath(self)`
    Normalize path, eliminating double slashes, etc.

- `@patch def delete(self)`
    Delete a file, symlink, or directory tree

- `class IterLen`
    Base class to add iteration to anything supporting `__len__` and `__getitem__`

    - `def __iter__(self)`

- `@docs class ReindexCollection`
    Reindexes collection `coll` with indices `idxs` and optional LRU cache of size `cache`

    - `def __init__(self, coll, idxs, cache, tfm)`
    - `def __getitem__(self, i)`
    - `def __len__(self)`
    - `def reindex(self, idxs)`
    - `def shuffle(self)`
    - `def cache_clear(self)`
    - `def __getstate__(self)`
    - `def __setstate__(self, s)`

- `class SaveReturn`
    Wrap an iterator such that the generator function's return value is stored in `.value`

    - `def __init__(self, its)`
    - `def __iter__(self)`

- `def trim_wraps(f, n)`
    Like wraps, but removes the first n parameters from the signature

- `def save_iter(g)`
    Decorator that allows a generator function to store values in the returned iterator object

- `def asave_iter(g)`
    Like `save_iter`, but for async iterators

- `def unqid(seeded)`
    Generate a unique id suitable for use as a Python identifier

- `def rtoken_hex(nbytes)`
    Generate a random hex string using Python's random module.

- `def friendly_name(levels, suffix)`
    Generate a random human-readable name with customizable word levels and suffix length

- `def n_friendly_names(levels, suffix)`
    Number of possible combos for `friendly_names

- `def exec_eval(code, g, l)`
    Evaluate `code` in `g` (defaults to `globals()`) and `l` (defaults to `locals()`)

- `def get_source_link(func)`
    Return link to `func` in source code

- `def sparkline(data, mn, mx, empty_zero)`
    Sparkline for `data`, with `None`s (and zero, if `empty_zero`) shown as empty column

- `def modify_exception(e, msg, replace)`
    Modifies `e` with a custom message attached

- `def round_multiple(x, mult, round_down)`
    Round `x` to nearest multiple of `mult`

- `def set_num_threads(nt)`
    Get numpy (and others) to use `nt` threads

- `def join_path_file(file, path, ext)`
    Return `path/file` if file is a string or a `Path`, file otherwise

- `def autostart(g)`
    Decorator that automatically starts a generator

- `class EventTimer`
    An event timer with history of `store` items of time `span`

    - `def __init__(self, store, span)`
    - `def add(self, n)`
        Record `n` events

    - `@property def duration(self)`
    - `@property def freq(self)`

- `def stringfmt_names(s)`
    Unique brace-delimited names in `s`

- `class PartialFormatter`
    A `string.Formatter` that doesn't error on missing fields, and tracks missing fields and unused args

    - `def __init__(self)`
    - `def get_field(self, nm, args, kwargs)`
    - `def check_unused_args(self, used, args, kwargs)`

- `def partial_format(s, **kwargs)`
    string format `s`, ignoring missing field errors, returning missing and extra fields

- `def truncstr(s, maxlen, suf, space, sizevar)`
    Truncate `s` to length `maxlen`, adding suffix `suf` if truncated

- `def utc2local(dt)`
    Convert `dt` from UTC to local time

- `def local2utc(dt)`
    Convert `dt` from local to UTC time

- `def trace(f)`
    Add `set_trace` to an existing function `f`

- `@contextmanager def modified_env(*delete, **replace)`
    Context manager temporarily modifying `os.environ` by deleting `delete` and replacing `replace`

- `class ContextManagers`
    Wrapper for `contextlib.ExitStack` which enters a collection of context managers

    - `def __init__(self, mgrs)`
    - `def __enter__(self)`
    - `def __exit__(self, *args, **kwargs)`

- `def shufflish(x, pct)`
    Randomly relocate items of `x` up to `pct` of `len(x)` from their starting location

- `def console_help(libname)`
    Show help for all console scripts from `libname`

- `def hl_md(s, lang, show)`
    Syntax highlight `s` using `lang`.

- `def type2str(typ)`
    Stringify `typ`

- `class Unset`
    - `def __repr__(self)`
    - `def __str__(self)`
    - `def __bool__(self)`
    - `@property def name(self)`
        The name of the Enum member.

    This is a reconstruction by astroid: enums are too dynamic to understand, but we at least
    know 'name' should be a string, so this is astroid's best guess.


- `def nullable_dc(cls)`
    Like `dataclass`, but default of `UNSET` added to fields without defaults

- `def flexiclass(cls)`
    Convert `cls` into a `dataclass` like `make_nullable`. Converts in place and also returns the result.

- `def asdict(o)`
    Convert `o` to a `dict`, supporting dataclasses, namedtuples, iterables, and `__dict__` attrs.

- `def vars_pub(x)`
    Get public non-skipped vars

- `def is_typeddict(cls)`
    Check if `cls` is a `TypedDict`

- `def is_namedtuple(cls)`
    `True` if `cls` is a namedtuple type

- `class CachedIter`
    Cache the result returned by an iterator

    - `def __init__(self, o)`
    - `def __iter__(self)`

- `class CachedAwaitable`
    Cache the result from an awaitable

    - `def __init__(self, o)`
    - `def __await__(self)`

- `def reawaitable(func)`
    Wraps the result of an asynchronous function into an object which can be awaited more than once

- `def flexicache(*funcs)`
    Like `lru_cache`, but customisable with policy `funcs`

- `def time_policy(seconds)`
    A `flexicache` policy that expires cached items after `seconds` have passed

- `def mtime_policy(filepath)`
    A `flexicache` policy that expires cached items after `filepath` modified-time changes

- `def timed_cache(seconds, maxsize)`
    Like `lru_cache`, but also with time-based eviction

